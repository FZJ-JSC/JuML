#Project Name
PROJECT(JuML)

# Set minimum CMAKE version#
CMAKE_MINIMUM_REQUIRED(VERSION 2.8.11)

# Set Compiler
SET(CMAKE_CXX_COMPILER "mpicxx")

# COMPILER FLAGS
SET(CMAKE_CXX_FLAGS "-std=c++0x -g -lhdf5 -lz")
FIND_PACKAGE(Threads REQUIRED)
FIND_PACKAGE(OpenMP REQUIRED)
if (OPENMP_FOUND)
    SET(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} ${OpenMP_C_FLAGS}")
    SET(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} ${OpenMP_CXX_FLAGS}")
endif()

# ADD ARRAYFIRE
SET(CMAKE_MODULE_PATH ${CMAKE_MODULE_PATH} "${CMAKE_CURRENT_SOURCE_DIR}/CMakeModules")
FIND_PACKAGE(ArrayFire REQUIRED)
INCLUDE_DIRECTORIES(${ArrayFire_INCLUDE_DIRS})
SET(AF_LIBS ${CMAKE_THREAD_LIBS_INIT}  ${ArrayFire_Unified_LIBRARIES})

# ADD HDF5
FIND_PACKAGE(HDF5 REQUIRED)
INCLUDE_DIRECTORIES(${HDF5_INCLUDE_DIRES})

# ADD MPI
FIND_PACKAGE(MPI REQUIRED)
INCLUDE_DIRECTORIES(${MPI_INCLUDE_DIRES})

# DEFINE MPI TEST FUNCTION
FUNCTION(ADD_MPI_TEST NAME TEST #[[MPI_PROCS]])
  FOREACH(PROCS ${ARGN})
    SET(TEST_PARAMETERS ${MPIEXEC_NUMPROC_FLAG} ${PROCS} "./${TEST}")
    ADD_TEST(NAME ${NAME}_${PROCS} COMMAND ${MPIEXEC} ${TEST_PARAMETERS})
  ENDFOREACH()
ENDFUNCTION(ADD_MPI_TEST)

# FIND OPENCL OPTIONAL
FIND_PACKAGE(OpenCL)
IF(OpenCL_FOUND)
    ADD_DEFINITIONS(-DJUML_OPENCL)
    LIST(APPEND AF_LIBS ${OpenCL_LIBRARIES})
ENDIF()

# FIND CUDA # OPTIONAL
FIND_PACKAGE(CUDA)
IF(CUDA_FOUND)
    FIND_PACKAGE(NVVM)
    ADD_DEFINITIONS(-DJUML_CUDA)
    LIST(APPEND AF_LIBS ${CUDA_LIBRARIES} ${NVVM_LIB})
ENDIF()

# ADD SOURCES
SET(JuML_INLUDE_DIRECTORIES ${PROJECT_SOURCE_DIR}/include)
INCLUDE_DIRECTORIES(${JuML_INLUDE_DIRECTORIES})
ADD_SUBDIRECTORY(src)

# ADD GOOGLE TEST # OPTIONAL
SET(JuML_DATA_DIRECTORY ${PROJECT_SOURCE_DIR}/datasets)
ADD_DEFINITIONS(-DJUML_DATASETS="${JuML_DATA_DIRECTORY}")
FIND_PACKAGE(GTest)
IF(GTEST_FOUND)
    INCLUDE_DIRECTORIES(${GTEST_INCLUDE_DIRS})
    # ADD UNIT TESTS
    INCLUDE(CTest)
    ADD_SUBDIRECTORY(tests)
    ENABLE_TESTING()
    # REDEFINE VERBOSE TEST COMMAND
    ADD_CUSTOM_TARGET(vtest ${CMAKE_COMMAND}
        -E env CTEST_OUTPUT_ON_FAILURE=1
        ${CMAKE_CTEST_COMMAND} -C $<CONFIG> --verbose
        WORKING_DIRECTORY ${CMAKE_BINARY_DIR}
    )
endif(GTEST_FOUND)


#Use Google cpplint to check our .cpp and .h files.
FIND_PACKAGE(PythonInterp)
IF(PYTHONINTERP_FOUND)
    FILE(GLOB_RECURSE lintable_cpp_files RELATIVE ${CMAKE_SOURCE_DIR} "src/*/*.cpp")
    FILE(GLOB_RECURSE lintable_h_files RELATIVE ${CMAKE_SOURCE_DIR} "include/*/*.h")
    ADD_CUSTOM_TARGET(lint ALL
        ${PYTHON_EXECUTABLE} ${CMAKE_SOURCE_DIR}/cpplint.py
	--verbose=3 #Reduce verbosity for now
	${lintable_cpp_files} ${lintable_h_files}
	COMMAND echo Finished
	WORKING_DIRECTORY ${CMAKE_SOURCE_DIR}
        COMMENT "Executing cpplint" VERBATIM
    )
ENDIF()

# ADD DOCUMENTATION # OPTIONAL
FIND_PACKAGE(Doxygen)
IF(DOXYGEN_FOUND)
  ADD_CUSTOM_TARGET(doc
    ${DOXYGEN_EXECUTABLE} ../doc/Doxyfile
    COMMENT "Generating API documentation with Doxygen" VERBATIM
  )
endif(DOXYGEN_FOUND)

# ADD PYTHON WRAPPER # OPTIONAL
ADD_SUBDIRECTORY(python)

# WORKARAOUND TO DISPLAY HEADERS IN IDE
FILE(GLOB_RECURSE header_files "${JuML_INLUDE_DIRECTORIES}/*/*.h")
add_custom_target(headers SOURCES ${header_files})
